
// 이진수 변환 찾아봄
// 패딩함수 사용법 찾아봄
function exam1(len, arr1, arr2){
	var i=0;
	var arr = [];

  function validCheck(num){
    var maxValue = Math.pow(2, len)-1;
    var minValue = 0;
    if(num > maxValue || num < minValue)
      throw "범위 초과";
  }

  function getBinary(num){
    var binary = num.toString(2);
    return binary.padStart(len, 0);
  }

  function lPad(str){
    return str.replace(/0/g, ' ').replace(/1/g, '#')
  }

	for(i;i<len;i++){
    var val1 = arr1[i], val2 = arr2[i];
    validCheck(val1);
    validCheck(val2);
  	var result = getBinary(val1 | val2);
		arr.push(lPad(result));
  }
	return arr;
}

// 정규식 테스트사이트 참고
function exam2(str){
  var state = 0;
  var regx = /\d+[SDT]([*#]?)+/g;
  var scoreRegx = /\d+/;
  var zoneRegx = /[SDT]/;
  var scores = [];

  function scoreCalc(score, zone, option){
    var currentScore = Math.pow(parseInt(score), {'S':1, 'D':2, 'T':3}[zone]);
    if(option === '*'){
      if(scores[state-1]){
        scores[state-1] *= 2;
      }
      scores[state] = currentScore*2;

    } else if(option === '#'){
      scores[state] = -currentScore;
    } else {
      scores[state] = currentScore;
    }
  }

  function sum(){
    var value = 0;
    scores.forEach(function(obj){
      value += obj;
    });
    return value;
  }

  var val;
  while((val = regx.exec(str)) !== null){
    val = val[0];
    var score = scoreRegx.exec(val)[0];
    var zone = zoneRegx.exec(val)[0];
    var option = val.replace(score+zone, '');
    scoreCalc(score, zone, option);
    state++;
  }
  console.log(str, sum());
}

function exam3(cacheSize, cities){
  var HIT = 1, MISS = 5;
  var cost = 0;
  var cacheList = [];

  function putCache(name){
    if(cacheList.length >= cacheSize)
      cacheList.splice(0,1);
    cacheList.push(name);
  }

  function getCache(name){
    var point = -1;
    var cache;
    cacheList.forEach(function(data, idx){
      if(name === data){
        point = idx;
      }
    });
    if(point !== -1){
      cost += HIT;
      cacheList.push(cache = test.splice(2,1)[0]);
    }else{
      cost += MISS;
    }
    return cache;
  }


  cities.forEach(function(city){
    var data = getCache(city);
    if(!data)
      putCache(city);
  });
  console.log('소요시간',  cost);
  return cost;

}

/**
입력 형식
셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 최대 크루 수 m, 크루가 대기열에 도착하는 시각을 모은 배열 timetable이 입력으로 주어진다.

0 ＜ n ≦ 10
0 ＜ t ≦ 60
0 ＜ m ≦ 45
timetable은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 HH:MM 형식으로 이루어져 있다.
크루의 도착 시각 HH:MM은 00:01에서 23:59 사이이다.
**/
function exam4(n, t, m, timetable){
	var CON;
	var busStartTime; // 버스운행시간

	timetable.sort(); // 타임테이블 정렬

	function initBustTime(){
		if(busStartTime === undefined){
			busStartTime = new Date(0);
			busStartTime.setHours(9);
			busStartTime.setMinutes(0);
		} else{
			busStartTime.setMinutes(busStartTime.getMinutes()+t);
		}
	}

	function initTime(str){
		var time = new Date(0);
		var split = str.split(':');
		time.setHours(split[0]);
		time.setMinutes(split[1]);
		return time;
	}

	var lastTime; // 마지막 탑승시각
	var isFull; // 만석여부
	var driveCnt = 0; // 운행횟수
	while(driveCnt++ < n){
		var cnt = 0; // 탑승인원
		isFull = false;
		initBustTime(); // 버스운행시간 초기화
		var i=0; len = timetable.length, clone = Array.from(timetable);
		for(;i<len;i++){
			var waitter = initTime(clone[i]);
			if(waitter <= busStartTime && cnt < m){
				if(++cnt === m){
					isFull = true;
					lastTime = waitter;
					break;
				}
			}
		}
		timetable.splice(0, cnt);
	}
	if(isFull){
		lastTime.setMinutes(lastTime.getMinutes()-1);
		CON = lastTime
	}else{
		CON = busStartTime;
	}

	CON = CON.getHours().toString().padStart(2,0) + ':' + CON.getMinutes().toString().padStart(2,0);
	console.log(CON);
	return CON;
}

exam4(1, 1, 5, ["08:00", "08:01", "08:02", "08:03"]);
exam4(2, 10, 2, ["09:10", "09:09", "08:00"]);
exam4(2, 1, 2, ["09:00", "09:00", "09:00", "09:00"]);
exam4(1, 1, 5, ["00:01", "00:01", "00:01", "00:01", "00:01"]);
exam4(1, 1, 1, ["23:59"]);
exam4(10, 60, 45, ["23:59","23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59"]);
