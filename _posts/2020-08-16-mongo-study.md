---
layout: posts
title:  몽고 기초 공부
date:   2020-08-16 13:00:00 +0900
comments: true
categories: study
---

* TOC
{:toc}

## 인덱스
- 단일 값이나 단일 필드는 인덱스를 생성해도 필드의 이름이 인덱스에 저장되지 않고 인덱스의 메타 정보에서만 관리되므로, 필드 이름의 크기는 인덱스의 크기에 영향을 미치지 않는다.  
    하지만 서브 도큐먼트를 값으로 가지는 필드는 그 서브 도큐먼트의 자식 필드 이름이 모두 인덱스에 저장되므로 자식 필드의 이름이 길면 그만큼 인덱스의 크기에 영향을 미친다.  
    서브 도큐먼트의 필드명이 길 때에는 이 값들이 인덱스의 크기를 훨씬 더 크게 만드는 역효과를 만들기도 한다.
- WiredTiger 스토리지 엔진은 데이터 파일은 기본적으로 압축을 적용하지만, 인덱스 데이터 파일은 압축을 하지 않는다.
- 인덱스 키값의 크기는 **1KB**를 넘을 수 없기 때문에 인덱스로 지정한 필드의 사이즈가 **1KB** 초과할 경우 오류를 발생시킨다.  
- 서브 도큐먼트 필드에 대해서 생성되는 인덱스를 사용하려면 조건절에 서브 도큐먼트의 필드를 모두 가지고, 순서가 같을 때만 인덱스를 활용할 수 있다.
- **인덱스 인터섹션**: 몽고디비에서는 대부분의 DBMS와 다르게 하나의 컬렉션이 가진 두 개 이상의 인덱스를 검색하여 각 검색 결과를 만들고, 그 결과 집합의 교집합을 찾는 최적화를 제공한다.  
    *책에서는 인덱스 인터섹션이 효율적인 경우가 별로 없다고 한다.*

### 컴파운드 인덱스

- 인덱스의 N번째 컬럼은 N-1번째 컬럼이 같은 레코드 내에서 다시 정렬된다. 그렇기 때문에 인데스 내에서 각 필드의 순서는 상당히 중요하며, 신중하게 결정해야 한다.
- N번째 컬럼없이 N-1번째 컬럼만으로는 인덱스를 사용할 수 없다.
- 해시 인덱스는 컴파운드 인덱스에서 사용할 수 없다. (B-Tree 알고리즘만 지원) 

아래와 같은 도큐먼트가 있을 때
```json
{
    "field1" : {
       "field1_1" : 111,
       "field1_2" : "aaa",
    },
    "field2" : "2020-08-16",
    "field3" : "박제희"
}
```

- 인덱스가 하나의 필드를 가지면 단일 필드라고 정의한다. 여기서 단일 필드는 서브 도큐먼트도 포함한다.  
    복합 필드 인덱스는 서브 도큐먼트의 필드도 포함할 수 있으며, 1레벨과 서브 도큐먼트의 필드와 혼용하는 것도 가능하다.
    - `field1` 를 지정하면 단일 필드이다.  
    - `field2` 를 지정하면 단일 필드이다.
- 인덱스가 복수의 필드를 가지면 복합 필드라고 정의한다. (컴파운드 인덱스 혹은 컴포지트 인덱스)
    - `field1` 과 `field2` 를 지정하면 복합 필드이다.
    - `field1.field1_1` 과 `field1.field1_2` 를 지정하면 복합 필드이다.
    - `field1.field1_1` 과 `field3` 를 지정하면 복합 필드이다.
    
서브 도큐먼트를 갖는 필드(`field1`) 를 대상으로 단일 인덱스 (`idx1`) 를 생성했을 때와 복합 인덱스(`idx2`)를 생성했을 때는 어떤 차이점이 존재할까?  
Ex)  
- `idx1`: `field1` 필드를 갖는 단일 인덱스
- `idx2`: `field1.field1_1` 과 `field1.field1_2` 필드를 갖는 복합 인덱스

`idx1` 는 `field1` 에 어떤 서브 도큐먼트가 저장되든 **BSON** 으로 변환하여 인덱스 키 엔트리로 사용한다.  
`idx2` 는 `field1` 에 저장되는 서브 도큐먼트가 어떤 필드를 가지던지 관계없이 인덱스에 명시한 서브 필드의 조합으로 컴파운드 인덱스를 생성한다.


### B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스 내에서 각 필드를 어떻게 정렬할 것인지는 인덱스를 최초에 생성하는 시점에 결정된다.
- 인덱스를 어떤 방향으로 읽을지는 쿼리가 원하는 값에 따라 옵티마이져가 만드는 실행계획에 따라 결정된다.

인덱스의 스캔 방향은 옵티마이저에 의해 결정되기 때문에, 인덱스 생성 시점에 조회 쿼리를 상상하며 ASC, DESC 를 고민할 필요는 없다.

컴파운드 인덱스에서 ASC 와 DESC 를 혼합해서 효과적으로 사용하는 경우는 어떤 경우인가?  
- 검색조건에 컴파운드 인덱스에 명시한 필드가 포함된다. 
- 정렬조건에 컴파운드 인덱스에 명시한 필드가 포함된다. (인덱스와 동일하게 혼합되어 있다면 인덱스 스캔 방향만 변경하여 탐색하면 되므로 인덱스에 최적화된 탐색이 가능하다) 
- 검색범위가 범위 검색이다 (동등 비교가 아니다)

### B-Tree 인덱스

### 해시 인덱스

- 필드값을 해싱하여 인덱스 키값을 관리하기 때문에 오직 동등성을 판단하는 검색에서만 인덱스를 사용할 수 있다.
- 해시 인덱스는 컴파운드 인덱스로 생성할 수 없다. (서브 도큐먼트는 가능)
- 몽고디비의 해시 인덱스는 내부적으로는 B-Tree 알고리즘을 이용한다.
- 인덱스를 생성할 때 인덱스 필드의 값을 **MD5** 알고리즘을 이용하여 저장하기 때문에 인덱스 필드의 크기와 관계없이 인덱스의 크기는 항상 **8Byte**이다.
- B-Tree 인덱스와 장점보다 단점이 많은 알고리즘으로, 특수한 상황에 인덱스의 특징을 알아야 적절히 사용할 수 있음 (**샤딩시 필수**)

### 멀티 키 인덱스
**하나의 도큐먼트**에 하나의 인덱스에 대하여 **여러개의 키**가 존재하면 멀티 키 인덱스라고 부른다.  
Ex)
아래와 같은 구조를 가지는 도큐먼트가 있을 때
```json
{
    "id" : "1",
    "multi" : [
        1,
        2,
        3,
        4,
        5
    ]
}
```
`multi` 필드에 대하여 인덱스를 생성하면 하나의 인덱스에 5개의 인덱스 키가 생성되는데 이것을 멀티 키 인덱스라고 부른다.

멀티 키를 이용하여 범위 검색을 할 때, 의식의 흐름대로 `BETWEEN` 연산을 이용하듯이 `find({ multi : { $gte : 3, $lte : 4 } })` 이런 쿼리를 작성하면
각 조건을 따로 비교한 다음에, 두 개의 결과를 병합한 결과를 리턴한다 (`or` 연산처럼 동작한다)

멀티 키를 이용하여 범위 검색을 하려면 `$elemMatch` 연산자를 이용해야 한다.  
`find({ multi : { $elemMatch: { $gte : 3, $lte : 4 } } })`

**제한사항**
- 샤드 키로 사용 불가
- 해시 알고리즘 사용 불가
- 커버링 인덱스 처리 불가
