<!doctype html> <!-- Minimal Mistakes Jekyll Theme 4.12.0 by Michael Rose Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes Free for personal and commercial use under the MIT license https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt --><html lang="ko" class="no-js"><head><meta charset="utf-8"> <!-- begin _includes/seo.html --><title>MongoDB 기초 공부 - JH Blog</title><meta name="description" content="developer JH website."><meta property="og:type" content="article"><meta property="og:locale" content="ko_KR"><meta property="og:site_name" content="JH Blog"><meta property="og:title" content="MongoDB 기초 공부"><meta property="og:url" content="https://jehuipark.github.io/study/mongo-study"><meta property="og:description" content="developer JH website."><meta property="article:published_time" content="2020-08-16T13:00:00+09:00"><meta property="fb:app_id" content="150481385751381"><link rel="canonical" href="https://jehuipark.github.io/study/mongo-study"> <script type="application/ld+json"> { "@context": "https://schema.org", "@type": "Person", "name": "Dev JH", "url": "https://jehuipark.github.io", "sameAs": null } </script><meta name="google-site-verification" content="googlece77ee37e1eecdba" /><meta name="naver-site-verification" content="naver4b9c5fbe228f7d5fc4264f265fee743a"> <!-- end _includes/seo.html --> <!--<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="JH Blog Feed">--><link rel="alternate" type="application/rss+xml" href="https://jehuipark.github.io/feed.xml" title="JH Blog Feed"> <!-- https://t.co/dKP3o1e --><meta name="viewport" content="width=device-width, initial-scale=1.0"> <script> document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js '; </script> <!-- For all browsers --><link rel="stylesheet" href="/assets/css/main.css"> <!--[if IE ]><style> /* old IE unsupported flexbox fixes */ .greedy-nav .site-title { padding-right: 3em; } .greedy-nav button { position: absolute; top: 0; right: 0; height: 100%; }</style><![endif]--> <script src="/assets/js/highlight.js"></script> <script src="/assets/js/highlightjs-line-numbers.min.js"></script> <!-- start custom head snippets --> <!--<link href="/assets/css/railscasts.css" rel="stylesheet" type="text/css">--><link href="/assets/css/zenburn.css" rel="stylesheet" type="text/css"> <!-- insert favicons. use https://realfavicongenerator.net/ --> <!-- end custom head snippets --><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"></head><body class="layout--posts"> <!--[if lt IE 9]><div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]--><div class="masthead"><div class="masthead__inner-wrap"><div class="masthead__menu"><nav id="site-nav" class="greedy-nav"> <a class="site-title" href="/">JH Blog</a><ul class="visible-links"><li class="masthead__menu-item"> <a href="/about/" >about</a></li><li class="masthead__menu-item"> <a href="/categories" >category</a></li><li class="masthead__menu-item"> <a href="/tags" >tag</a></li></ul><button class="search__toggle" type="button"> <span class="visually-hidden">Toggle search</span> <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16"><path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path> </svg> </button> <button class="greedy-nav__toggle hidden" type="button"> <span class="visually-hidden">토글 메뉴</span><div class="navicon"></div></button><ul class="hidden-links hidden"></ul></nav></div></div></div><div class="initial-content"><div id="main" role="main"><div class="sidebar sticky"><div itemscope itemtype="https://schema.org/Person"><div class="author__avatar"> <img src="/assets/images/me.jpg" alt="JeHui Park" itemprop="image"></div><div class="author__content"><h3 class="author__name" itemprop="name">JeHui Park</h3><p class="author__bio" itemprop="description"> 개발자 박제희</p></div><div class="author__urls-wrapper"> <button class="btn btn--inverse">팔로우</button><ul class="author__urls social-icons"><li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place"> <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Seoul, Korea</span></li><li> <a href="https://jehuipark.github.io" itemprop="url"> <i class="fas fa-fw fa-link" aria-hidden="true"></i> 웹사이트 </a></li><li> <a href="mailto:pjh2359@gmail.com"><meta itemprop="email" content="pjh2359@gmail.com" /> <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> 이메일 </a></li><li> <a href="https://github.com/JeHuiPark" itemprop="sameAs" rel="nofollow noopener noreferrer"> <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub </a></li><!--<li> <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer"> <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link </a></li>--></ul></div></div></div><div class="archive"><h1 id="page-title" class="page__title">MongoDB 기초 공부</h1><ul id="markdown-toc"><li><a href="#인덱스" id="markdown-toc-인덱스">인덱스</a><ul><li><a href="#컴파운드-인덱스" id="markdown-toc-컴파운드-인덱스">컴파운드 인덱스</a></li><li><a href="#b-tree-인덱스의-정렬-및-스캔-방향" id="markdown-toc-b-tree-인덱스의-정렬-및-스캔-방향">B-Tree 인덱스의 정렬 및 스캔 방향</a></li><li><a href="#b-tree-인덱스" id="markdown-toc-b-tree-인덱스">B-Tree 인덱스</a></li><li><a href="#해시-인덱스" id="markdown-toc-해시-인덱스">해시 인덱스</a></li><li><a href="#멀티-키-인덱스" id="markdown-toc-멀티-키-인덱스">멀티 키 인덱스</a></li><li><a href="#프라이머리-키와-세컨드리-인덱스" id="markdown-toc-프라이머리-키와-세컨드리-인덱스">프라이머리 키와 세컨드리 인덱스</a></li><li><a href="#유니크-인덱스" id="markdown-toc-유니크-인덱스">유니크 인덱스</a></li><li><a href="#sparse-인덱스-와-partial-인덱스" id="markdown-toc-sparse-인덱스-와-partial-인덱스">Sparse 인덱스 와 Partial 인덱스</a><ul><li><a href="#불완전한-결과" id="markdown-toc-불완전한-결과">불완전한 결과</a></li></ul></li><li><a href="#ttl-인덱스" id="markdown-toc-ttl-인덱스">TTL 인덱스</a></li><li><a href="#인덱스-콜레이션" id="markdown-toc-인덱스-콜레이션">인덱스 콜레이션</a></li></ul></li><li><a href="#잠금" id="markdown-toc-잠금">잠금</a><ul><li><a href="#잠금-양보-yield" id="markdown-toc-잠금-양보-yield">잠금 양보 (Yield)</a></li></ul></li><li><a href="#트랜잭션" id="markdown-toc-트랜잭션">트랜잭션</a><ul><li><a href="#쓰기충돌-write-conflict" id="markdown-toc-쓰기충돌-write-conflict">쓰기충돌 (Write Conflict)</a></li><li><a href="#단일-도큐먼트-트랜잭션" id="markdown-toc-단일-도큐먼트-트랜잭션">단일 도큐먼트 트랜잭션</a></li><li><a href="#mongodb-서버의-격리-수준과-정렬" id="markdown-toc-mongodb-서버의-격리-수준과-정렬">MongoDB 서버의 격리 수준과 정렬</a></li><li><a href="#readconcern-writeconcern-readpreference" id="markdown-toc-readconcern-writeconcern-readpreference">ReadConcern, WriteConcern, ReadPreference</a><ul><li><a href="#writeconcern" id="markdown-toc-writeconcern">WriteConcern</a></li><li><a href="#레플리카-셋-간의-동기화-제어" id="markdown-toc-레플리카-셋-간의-동기화-제어">레플리카 셋 간의 동기화 제어</a></li></ul></li><li><a href="#readconcern" id="markdown-toc-readconcern">ReadConcern</a></li><li><a href="#readpreference" id="markdown-toc-readpreference">ReadPreference</a></li></ul></li><li><a href="#데이터-모델링" id="markdown-toc-데이터-모델링">데이터 모델링</a><ul><li><a href="#컬렉션" id="markdown-toc-컬렉션">컬렉션</a></li><li><a href="#뷰" id="markdown-toc-뷰">뷰</a></li><li><a href="#bson-도큐먼트" id="markdown-toc-bson-도큐먼트">BSON 도큐먼트</a></li><li><a href="#정규화-역정규화" id="markdown-toc-정규화-역정규화">정규화, 역정규화</a></li><li><a href="#쿼리-개발-및-튜닝" id="markdown-toc-쿼리-개발-및-튜닝">쿼리 개발 및 튜닝</a></li><li><a href="#쿼리-실행계획" id="markdown-toc-쿼리-실행계획">쿼리 실행계획</a></li></ul></li><li><a href="#참고서적" id="markdown-toc-참고서적">참고서적</a></li><li><a href="#연결" id="markdown-toc-연결">연결</a></li></ul><h2 id="인덱스">인덱스</h2><ul><li>단일 값이나 단일 필드는 인덱스를 생성해도 필드의 이름이 인덱스에 저장되지 않고 인덱스의 메타 정보에서만 관리되므로, 필드 이름의 크기는 인덱스의 크기에 영향을 미치지 않는다.<br /> 하지만 서브 도큐먼트를 값으로 가지는 필드는 그 서브 도큐먼트의 자식 필드 이름이 모두 인덱스에 저장되므로 자식 필드의 이름이 길면 그만큼 인덱스의 크기에 영향을 미친다.<br /> 서브 도큐먼트의 필드명이 길 때에는 이 값들이 인덱스의 크기를 훨씬 더 크게 만드는 역효과를 만들기도 한다.</li><li>WiredTiger 스토리지 엔진은 데이터 파일은 기본적으로 압축을 적용하지만, 인덱스 데이터 파일은 압축을 하지 않는다.</li><li>인덱스 키값의 크기는 <strong>1KB</strong>를 넘을 수 없기 때문에 인덱스로 지정한 필드의 사이즈가 <strong>1KB</strong> 초과할 경우 오류를 발생시킨다.</li><li>서브 도큐먼트 필드에 대해서 생성되는 인덱스를 사용하려면 조건절에 서브 도큐먼트의 필드를 모두 가지고, 순서가 같을 때만 인덱스를 활용할 수 있다.</li><li><strong>인덱스 인터섹션</strong>: MongoDB에서는 대부분의 DBMS와 다르게 하나의 컬렉션이 가진 두 개 이상의 인덱스를 검색하여 각 검색 결과를 만들고, 그 결과 집합의 교집합을 찾는 최적화를 제공한다.<br /> <em>책에서는 인덱스 인터섹션이 효율적인 경우가 별로 없다고 한다.</em></li></ul><p>*공간 인덱스와 전문 인덱스는 아직 나의 관심사가 아니므로 공부 대상에서 제외한다**</p><h3 id="컴파운드-인덱스">컴파운드 인덱스</h3><ul><li>인덱스의 N번째 컬럼은 N-1번째 컬럼이 같은 레코드 내에서 다시 정렬된다. 그렇기 때문에 인데스 내에서 각 필드의 순서는 상당히 중요하며, 신중하게 결정해야 한다.</li><li>N번째 컬럼없이 N-1번째 컬럼만으로는 인덱스를 사용할 수 없다.</li><li>해시 인덱스는 컴파운드 인덱스에서 사용할 수 없다. (B-Tree 알고리즘만 지원)</li></ul><p>아래와 같은 도큐먼트가 있을 때</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"field1"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="nl">"field1_1"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">111</span><span class="p">,</span><span class="w">
       </span><span class="nl">"field1_2"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"aaa"</span><span class="p">,</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"field2"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"2020-08-16"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"field3"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"박제희"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><ul><li>인덱스가 하나의 필드를 가지면 단일 필드라고 정의한다. 여기서 단일 필드는 서브 도큐먼트도 포함한다.<br /> 복합 필드 인덱스는 서브 도큐먼트의 필드도 포함할 수 있으며, 1레벨과 서브 도큐먼트의 필드와 혼용하는 것도 가능하다.<ul><li><code class="highlighter-rouge">field1</code> 를 지정하면 단일 필드이다.</li><li><code class="highlighter-rouge">field2</code> 를 지정하면 단일 필드이다.</li></ul></li><li>인덱스가 복수의 필드를 가지면 복합 필드라고 정의한다. (컴파운드 인덱스 혹은 컴포지트 인덱스)<ul><li><code class="highlighter-rouge">field1</code> 과 <code class="highlighter-rouge">field2</code> 를 지정하면 복합 필드이다.</li><li><code class="highlighter-rouge">field1.field1_1</code> 과 <code class="highlighter-rouge">field1.field1_2</code> 를 지정하면 복합 필드이다.</li><li><code class="highlighter-rouge">field1.field1_1</code> 과 <code class="highlighter-rouge">field3</code> 를 지정하면 복합 필드이다.</li></ul></li></ul><p>서브 도큐먼트를 갖는 필드(<code class="highlighter-rouge">field1</code>) 를 대상으로 단일 인덱스 (<code class="highlighter-rouge">idx1</code>) 를 생성했을 때와 복합 인덱스(<code class="highlighter-rouge">idx2</code>)를 생성했을 때는 어떤 차이점이 존재할까?<br /> Ex)</p><ul><li><code class="highlighter-rouge">idx1</code>: <code class="highlighter-rouge">field1</code> 필드를 갖는 단일 인덱스</li><li><code class="highlighter-rouge">idx2</code>: <code class="highlighter-rouge">field1.field1_1</code> 과 <code class="highlighter-rouge">field1.field1_2</code> 필드를 갖는 복합 인덱스</li></ul><p><code class="highlighter-rouge">idx1</code> 는 <code class="highlighter-rouge">field1</code> 에 어떤 서브 도큐먼트가 저장되든 <strong>BSON</strong> 으로 변환하여 인덱스 키 엔트리로 사용한다.<br /> <code class="highlighter-rouge">idx2</code> 는 <code class="highlighter-rouge">field1</code> 에 저장되는 서브 도큐먼트가 어떤 필드를 가지던지 관계없이 인덱스에 명시한 서브 필드의 조합으로 컴파운드 인덱스를 생성한다.</p><h3 id="b-tree-인덱스의-정렬-및-스캔-방향">B-Tree 인덱스의 정렬 및 스캔 방향</h3><ul><li>인덱스 내에서 각 필드를 어떻게 정렬할 것인지는 인덱스를 최초에 생성하는 시점에 결정된다.</li><li>인덱스를 어떤 방향으로 읽을지는 쿼리가 원하는 값에 따라 옵티마이져가 만드는 실행계획에 따라 결정된다.</li></ul><p>인덱스의 스캔 방향은 옵티마이저에 의해 결정되기 때문에, 인덱스 생성 시점에 조회 쿼리를 상상하며 ASC, DESC 를 고민할 필요는 없다.</p><p>컴파운드 인덱스에서 ASC 와 DESC 를 혼합해서 효과적으로 사용하는 경우는 어떤 경우인가?</p><ul><li>검색조건에 컴파운드 인덱스에 명시한 필드가 포함된다.</li><li>정렬조건에 컴파운드 인덱스에 명시한 필드가 포함된다. (인덱스와 동일하게 혼합되어 있다면 인덱스 스캔 방향만 변경하여 탐색하면 되므로 인덱스에 최적화된 탐색이 가능하다)</li><li>검색범위가 범위 검색이다 (동등 비교가 아니다)</li></ul><h3 id="b-tree-인덱스">B-Tree 인덱스</h3><h3 id="해시-인덱스">해시 인덱스</h3><ul><li>필드값을 해싱하여 인덱스 키값을 관리하기 때문에 오직 동등성을 판단하는 검색에서만 인덱스를 사용할 수 있다.</li><li>해시 인덱스는 컴파운드 인덱스로 생성할 수 없다. (서브 도큐먼트는 가능)</li><li>MongoDB의 해시 인덱스는 내부적으로는 B-Tree 알고리즘을 이용한다.</li><li>인덱스를 생성할 때 인덱스 필드의 값을 <strong>MD5</strong> 알고리즘을 이용하여 저장하기 때문에 인덱스 필드의 크기와 관계없이 인덱스의 크기는 항상 <strong>8Byte</strong>이다.</li><li>B-Tree 인덱스와 장점보다 단점이 많은 알고리즘으로, 특수한 상황에 인덱스의 특징을 알아야 적절히 사용할 수 있음 (<strong>샤딩시 필수</strong>)</li></ul><h3 id="멀티-키-인덱스">멀티 키 인덱스</h3><p><strong>하나의 도큐먼트</strong>에 하나의 인덱스에 대하여 <strong>여러개의 키</strong>가 존재하면 멀티 키 인덱스라고 부른다.<br /> Ex) 아래와 같은 구조를 가지는 도큐먼트가 있을 때</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"id"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"1"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"multi"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="mi">1</span><span class="p">,</span><span class="w">
        </span><span class="mi">2</span><span class="p">,</span><span class="w">
        </span><span class="mi">3</span><span class="p">,</span><span class="w">
        </span><span class="mi">4</span><span class="p">,</span><span class="w">
        </span><span class="mi">5</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div><p><code class="highlighter-rouge">multi</code> 필드에 대하여 인덱스를 생성하면 하나의 인덱스에 5개의 인덱스 키가 생성되는데 이것을 멀티 키 인덱스라고 부른다.</p><p>멀티 키를 이용하여 범위 검색을 할 때, 의식의 흐름대로 <code class="highlighter-rouge">BETWEEN</code> 연산을 이용하듯이 <code class="highlighter-rouge">find({ multi : { $gte : 3, $lte : 4 } })</code> 이런 쿼리를 작성하면 각 조건을 따로 비교한 다음에, 두 개의 결과를 병합한 결과를 리턴한다 (<code class="highlighter-rouge">or</code> 연산처럼 동작한다)</p><p>멀티 키를 이용하여 범위 검색을 하려면 <code class="highlighter-rouge">$elemMatch</code> 연산자를 이용해야 한다.<br /> <code class="highlighter-rouge">find({ multi : { $elemMatch: { $gte : 3, $lte : 4 } } })</code></p><p><strong>제한사항</strong></p><ul><li>샤드 키로 사용 불가</li><li>해시 알고리즘 사용 불가</li><li>커버링 인덱스 처리 불가</li></ul><h3 id="프라이머리-키와-세컨드리-인덱스">프라이머리 키와 세컨드리 인덱스</h3><ul><li>MongoDB의 프라이머리 키는 강제되며, 무조건 <code class="highlighter-rouge">_id</code> 라는 이름으로 도큐먼트에 저장 되어야 한다.</li><li>컬렉션마다 단 하나의 프라이머리 키만 가질 수 있으며, 나머지 인덱스는 모두 세컨드리 인덱스라고 한다.</li><li>컬렉션이 샤딩 되어있는 경우에는 하나의 샤드에서 중복 값에 대한 체크는 MongoDB 서버에서 처리하지만, 각 샤드간 프라이머리 키 값의 중복 체크는 응용 프로그램에서 처리해야 한다.</li></ul><h3 id="유니크-인덱스">유니크 인덱스</h3><ul><li><code class="highlighter-rouge">NULL</code> 값을 제한하지 않는다</li><li><code class="highlighter-rouge">NULL</code> 과 존재하지 않는 값(도큐먼트에 필드를 명시하지 않음)을 동일하게 취급한다</li><li>도큐먼트 간의 중복값은 체크를 하지만, 도큐먼트 내부에서 중복된 값을 체크하지는 않는다.</li><li>샤딩이 적용된 경우에는 샤드키를 선행 필드로 가지는 인덱스에서만 유니크 인덱스를 생성할 수 있다.</li><li>해시 알고리즘을 적용할 수 없다. (해시 충돌 가능성을 가지고 있기 때문)</li><li>Mongo DB 의 유니크 인덱스는 일반 인덱스와 동일한 역할을 하므로 중복해서 인덱스를 생성하지 않도록 한다.</li></ul><h3 id="sparse-인덱스-와-partial-인덱스">Sparse 인덱스 와 Partial 인덱스</h3><ul><li><strong>Sparse</strong> 인덱스<ul><li>인덱스 대상 필드를 명시한 도큐먼트만 인덱스에 키 엔트리를 저장한다. (<code class="highlighter-rouge">NULL</code> 포함)</li><li>컴파운드 인덱스인 경우에는 인덱스를 구성하는 필드 중에서 하나라도 명시하면 인덱싱 대상이 된다.</li><li>인덱스가 커버할 수 없는 쿼리에서는 인덱스를 사용할 수 없다</li></ul></li><li><strong>Partial</strong> 인덱스 : 특정 조건에 따라 인덱싱 가능<ul><li>인덱스를 생성할 때 <code class="highlighter-rouge">partialFilterExpression</code> 옵션을 이용하여 인덱스 생성 조건을 명시</li><li>인덱스 생성 조건에는 인덱스 대상 필드와 무관한 필드에 대해서도 조건으로 사용하는 것이 가능하다.</li><li>Partial 인덱스를 사용하려면 <strong>인덱스 생성 조건과 일치</strong>하거나 부분 범위의 조건을 명시해야만 한다</li><li>샤드키에 사용 불가</li><li>인덱스가 커버할 수 없는 쿼리에서는 인덱스를 사용할 수 없다</li></ul></li></ul><h4 id="불완전한-결과">불완전한 결과</h4><p>Sparse 인덱스나 Partial 인덱스는 컬렉션에 저장되는 도큐먼트가 특정 조건을 만족하는 경우에만 인덱싱을 진행하게 된다.<br /> 그렇기 때문에 인덱스로 참조할 수 없는 도큐먼트가 분명히 존재하게 되어 인덱스 탐색을 하게 될 경우에 불완전환 결과를 리턴할 수 있다.<br /> 그래서 옵티마이저는 인덱스가 커버할 수 없는 쿼리라고 판단하면 인덱스를 사용하지 않도록 하고 있지만, 사용자가 인덱스 힌트를 직접 명시하면 옵티마이저는 사용자가 이런 불완전한 결과에 대한 가능성을 충분히 인지하고 있다고 가정하고 인덱스 탐색을 하도록 실행 계획을 수립하도록 한다.</p><p>예시)</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 컬렉션과 Sparse 인덱스 생성</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">createCollection</span><span class="p">(</span><span class="dl">"</span><span class="s2">sample</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">sample</span><span class="p">.</span><span class="nx">createIndex</span><span class="p">({</span>
    <span class="dl">"</span><span class="s2">field</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">1</span>
<span class="p">},</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">sparse</span><span class="dl">"</span> <span class="p">:</span> <span class="kc">true</span>
<span class="p">});</span>

<span class="c1">// 더미 데이터 생성</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">sample</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span>
    <span class="na">_id</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">AAA</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">field</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">1</span>
<span class="p">});</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">sample</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span>
    <span class="na">_id</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">BBB</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">field</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">2</span>
<span class="p">});</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">sample</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span>
    <span class="na">_id</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">3</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">CCC</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">field</span><span class="dl">"</span> <span class="p">:</span> <span class="kc">null</span>
<span class="p">});</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">sample</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span>
    <span class="na">_id</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">4</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">DDD</span><span class="dl">"</span>
<span class="p">});</span>

<span class="c1">// 인덱스를 사용하지 않지만 완전한 결과</span>
<span class="c1">// 3과 4 도큐먼트를 리턴한다.</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">sample</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span>
   <span class="dl">"</span><span class="s2">field</span><span class="dl">"</span> <span class="p">:</span> <span class="kc">null</span>
<span class="p">});</span>

<span class="c1">// 인덱스를 사용하지만 불완전한 결과</span>
<span class="c1">// 3 도큐먼트만 리턴한다.</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">sample</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span>
   <span class="dl">"</span><span class="s2">field</span><span class="dl">"</span> <span class="p">:</span> <span class="kc">null</span>
<span class="p">}).</span><span class="nx">hint</span><span class="p">({</span> <span class="dl">"</span><span class="s2">field</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">});</span>
</code></pre></div></div><h3 id="ttl-인덱스">TTL 인덱스</h3><p>컬렉션의 도큐먼트가 언제까지 유효한지를 판단하여 더 이상 유효하지 않은 도큐먼트는 자동으로 삭제되게 하는 기능의 인덱스<br /> 도큐먼트 삭제는 TTL Monitor 라는 쓰레드가 지정된 시간 간격(기본:1분)마다 지정된 시간보다 오래된 도큐먼트를 찾아서 삭제한다.<br /> TTL 인덱스는 쿼리의 검색 성능 향상 목적보다는 TTL Monitor 쓰레드가 삭제할 도큐먼트를 찾기 위한 인덱스로 보는게 정확하다.</p><p>TTL 인덱스는 지정된 필드가 Date 타입이거나 Date 타입의 값을 배열로 가지는 필드에 대해서만 자동 삭제가 실행된다.</p><p>예시 )</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">createIndex</span><span class="p">(</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">created</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">expireAfterSeconds</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">600</span> <span class="p">}</span> <span class="p">)</span>

<span class="c1">// TTL Monitor 수도코드</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">created</span> <span class="o">+</span> <span class="mi">600</span> <span class="o">&lt;</span> <span class="nx">NOW</span><span class="p">)</span> <span class="nx">remove</span><span class="p">();</span>
</code></pre></div></div><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">token</span><span class="p">.</span><span class="nx">createIndex</span><span class="p">(</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">expiredDateTime</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">expireAfterSeconds</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">)</span>

<span class="c1">// TTL Monitor 수도코드</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">expiredDateTime</span> <span class="o">&lt;</span> <span class="nx">NOW</span><span class="p">)</span> <span class="nx">remove</span><span class="p">();</span>
</code></pre></div></div><p><strong>Partial 인덱스 옵션과 조합하여 선별적 자동 삭제도 가능하다.</strong></p><p>예시 )</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">createIndex</span><span class="p">(</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">created</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">created</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">600</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">partialFilterExpression</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">is_admin</span><span class="dl">"</span> <span class="p">:</span> <span class="kc">false</span> <span class="p">}</span>
<span class="p">})</span>

<span class="c1">// TTL Monitor 수도코드</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">created</span> <span class="o">+</span> <span class="mi">600</span> <span class="o">&lt;</span> <span class="nx">NOW</span> <span class="o">&amp;&amp;</span> <span class="nx">isNotAdmin</span><span class="p">())</span> <span class="nx">remove</span><span class="p">();</span>
</code></pre></div></div><h3 id="인덱스-콜레이션">인덱스 콜레이션</h3><p>MongoDB는 모든 문자열 비교에서 대소문자를 구분하는 Case-Sensitive 방식이다.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span> <span class="na">name</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">jehui</span><span class="dl">"</span> <span class="p">});</span>

<span class="nx">db</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span> <span class="na">name</span> <span class="p">:</span> <span class="dl">"</span><span class="s2">Jehui</span><span class="dl">"</span> <span class="p">});</span>
<span class="c1">// &gt;&gt; not found</span>
</code></pre></div></div><p>3.4 버전 부터 컬렉션과 인덱스에 대해서 콜레이션을 지정가능 컬레이션을 지정하면 영어의 대소문자 비교 구분뿐만 아니라 국가별 언어에 맞는 정렬 및 비교 규칙을 사용자의 요구사항에 맞게 적절히 선택할 수 있다.</p><ul><li>컬렉션의 인덱스를 생성한 이후에는 다른 콜레이션으로 변경할 수 없다. (콜레이션을 변경하라면 인덱스 삭제 -&gt; 생성 과정을 거쳐야 한다.)</li><li>인덱스를 생성할 때 별도의 콜레이션을 명시하지 않으면 컬렉션의 기본 콜레이션을 상속받게 된다.</li></ul><h2 id="잠금">잠금</h2><p><strong>WiredTiger</strong> 스토리지 엔진은 글로벌(인스턴스 레벨) 잠금과 데이터베이스와 컬렉션 레벨의 인텐션 잠금을 지원한다.<br /> 인텐션 잠금은 데이터베이스 레벨이나 컬렉션 레벨의 명령과 도큐먼트 레벨의 명령이 최적의 동시성을 유지하면서 실행될 수 있게 해준다.</p><h3 id="잠금-양보-yield">잠금 양보 (Yield)</h3><p>MongoDB 서버는 트랜잭션보다는 높은 동시성 처리의 우선순위가 더 높기 때문에 설정된 시간보다 오래 걸리거나, 많은 자원을 소모하는 경우에는 잠깐 쉬었다(Yield)가 다시 처리한다.</p><ol><li>읽기를 위한 IS 잠금(Intention Shared) 획득 (REV1 스냅샷 획득)</li><li>데이터 탐색</li><li>잠금 양보 (스냅샷 해제)</li><li>읽기를 위한 IS 잠금(Intention Shared) 획득 (REV2 스냅샷 획득)</li><li>loop …</li></ol><p>이러한 특성 때문에 쿼리 일관성이 깨질 수 있다는 문제점을 가지고 있음</p><p>관련 설정</p><ul><li><code class="highlighter-rouge">internalQueryExecYieldIterations</code></li><li><code class="highlighter-rouge">internalQueryExecYieldPeriodMs</code></li></ul><h2 id="트랜잭션">트랜잭션</h2><p>2.6 버전 까지 사용되던 <strong>MMAPv1</strong> 스토리지 엔진은 트랜잭션이라고 할 만한 요소가 별로 없다. (대부분 운영체제 시스템 콜에 의존)</p><p><strong>WiredTiger</strong> 스토리지 엔진이 제공하는 트랜잭션의 <strong>ACID</strong> 속성</p><ul><li>최고 레벨의 격리 수준은 <strong>SNAPSHOT</strong>(RR)</li><li>트랜잭션의 커밋과 체크포인트 2가지 형태로 영속성 보장</li><li>커밋되지 않은 변경 데이터는 공유 캐시 크기보다 작아야 함</li></ul><p>MongoDB 서버에 내장된 <strong>WiredTiger</strong> 의 격리 수준은 <strong>SNAPSHOT</strong>으로 고정되어 있다.<br /> MongoDB 서버는 <strong>WiredTiger</strong> 스토리지 엔진의 <strong>SNAPSHOT</strong> 격리수준을 100% 지원하지는 않는다.</p><h3 id="쓰기충돌-write-conflict">쓰기충돌 (Write Conflict)</h3><p>MongoDB는 쓰기 충돌이 발생하면 RDBMS 와는 다른 방식으로 해결한다.<br /> <img src="https://user-images.githubusercontent.com/25237661/90974620-e683a200-e567-11ea-81cb-e6669c657693.png" alt="image" /></p><p>변경하고자 하는 도큐먼트에 잠금이 걸려있을 경우에는 즉시 업데이트 실행을 취소하고 재시도를 수행한다.<br /> 이런 과정들은 MongoDB 서버 프로세스 내부에서만 실행되기 때문에 응용 프로그램에는 투명하게 작동한다.</p><p>기존 RDBMS 는 쓰기 충돌이 발생하면 잠금 대기상태에 들어가기 때문에 커넥션이 일시적으로 증가하는 반면에 MongoDB 는 UPDATE 문을 재시도하는 방식이기 때문에 하나의 도큐먼트에 변경이 집중되면 <strong>쓰기 충돌→재시도</strong> 과정이 반복되어 CPU 의 사용량이 높아지는 현상이 발생될 수 있다. (CPU 사용량만 증가하고 처리능력은 저하된다)</p><h3 id="단일-도큐먼트-트랜잭션">단일 도큐먼트 트랜잭션</h3><p>MongoDB 서버는 단일 도큐먼트의 트랜잭션만 지원한다. 단일 도큐먼트의 변경에 대해서는 원자 단위의 처리가 보장 되지만, <strong>문장 단위의 트랜잭션은 지원되지 않는다.</strong> (MongoDB 서버에서 작업을 쪼개서 진행)</p><p>예시)</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">insert</span><span class="p">([</span>
  <span class="p">{</span><span class="na">_id</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">AAA</span><span class="dl">"</span><span class="p">},</span>
  <span class="p">{</span><span class="na">_id</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">BBB</span><span class="dl">"</span><span class="p">},</span>
<span class="p">])</span>

<span class="c1">// 몽고DB 수도코드</span>
<span class="nx">BEGIN</span>
    <span class="nx">db</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span><span class="na">_id</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">AAA</span><span class="dl">"</span><span class="p">})</span>
<span class="nx">END</span>

<span class="nx">BEGIN</span>
    <span class="nx">db</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">insert</span><span class="p">({</span><span class="na">_id</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">BBB</span><span class="dl">"</span><span class="p">})</span>
<span class="nx">END</span>
</code></pre></div></div><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">find</span><span class="p">()</span>
<span class="c1">// &gt; {_id:1, name:"AAA"}</span>
</code></pre></div></div><p><code class="highlighter-rouge">{multi:true}</code> 옵션을 명시한 <strong>UPDATE</strong> 명령도 동일하다</p><h3 id="mongodb-서버의-격리-수준과-정렬">MongoDB 서버의 격리 수준과 정렬</h3><p>MongoDB 서버는 도큐먼트를 조회할 때 기본적으로 스냅샷을 기반으로 처리하며 스냅샷은 도큐먼트 건수나 일정 시간을 기준으로 초기화가 진행된다.<br /> 그런데 실행하는 쿼리가 <strong>정렬</strong>이 필요하다면 MongoDB 서버는 컬렉션의 데이터를 모두 가져와서 메모리에 적재하고 정렬을 실행하여 그 결과를 클라이언트로 보내게 된다.</p><p>요약하면 정렬이 포함되지 않거나 정렬이 인덱스로 보장될(정렬 SKIP) 때에는 스냅샷 격리 수준이 제한적으로만 보장된다.</p><h3 id="readconcern-writeconcern-readpreference">ReadConcern, WriteConcern, ReadPreference</h3><p><strong>ReadConcern</strong> 과 <strong>WriteConcern</strong> 는 데이터 읽기/쓰기를 시도할 때 동기화 수준을 결정 <strong>ReadPreference</strong> 는 레플리카 셋의 어느 MongoDB 서버로 요청을 보낼 것인지 결정</p><h4 id="writeconcern">WriteConcern</h4><p>클라이언트의 변경요청을 어디까지 처리하고 응답을 내려보낼 것인지 결정하는 옵션으로 클라이언트, 데이터베이스, 컬렉션 수준까지 지정이 가능하다</p><ul><li><code class="highlighter-rouge">UNACKNOWLEDGED</code> 변경 요청에 대한 응답을 기다리지 않는다</li><li><code class="highlighter-rouge">ACKNOWLEDGED</code> 변경 내용을 메모리까지만 적용하고 클라이언트로 응답을 보낸다 (기본값)</li><li><code class="highlighter-rouge">JOURNALED</code> 변경 내용을 저널로그까지 기록하고 클라이언트로 응답을 보낸다 (2.6 버전부터 지원)</li><li><code class="highlighter-rouge">FSYNC</code> 변경 내용을 데이터파일까지 기록하고 클라이언트로 응답을 보낸다.<ul><li>MMAPv1 스토리지 엔진에서 사용되던 옵션</li><li>WiredTiger 스토리지 엔진은 이 스펙을 지원하지 않는다 (저널로그로 대체)</li><li>클라이언트의 드라이버에서 제거될 옵션이다</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/25237661/92327939-300bdb00-f098-11ea-8404-952cb435dc08.png" alt="image" /></p><h4 id="레플리카-셋-간의-동기화-제어">레플리카 셋 간의 동기화 제어</h4><p>레플리카 셋에서 변경 결과를 어느정도 수준으로 동기화 시킬건지 제어할 수 있다.</p><ul><li><code class="highlighter-rouge">{ w : 2 }</code> 레플리카 셋에서 2대 이상의 멤버가 <strong>WriteConcern</strong> 조건을 만족 해야한다.</li><li><code class="highlighter-rouge">{ w : "majority"}</code> 레플리카 셋에서 과반수 이상의 멤버가 <strong>WriteConcern</strong> 조건을 만족 해야한다.</li></ul><h3 id="readconcern">ReadConcern</h3><p><strong>WriteConcern</strong> 옵션에 따라 MongoDB 레플리카 셋의 멤버들은 서로 다른 상태를 가질 수 있다.<br /> 이런 특징이 데이터를 읽어갈 때 문제점을 유발할 가능성이 있기 때문에 데이터 읽기를 일관성 있게 유지할 수 있도록 지원하는 옵션이다</p><ul><li><code class="highlighter-rouge">local</code> 쿼리가 실행되는 MongoDB 서버가 가진 최신의 데이터를 반환 (기본값)</li><li><code class="highlighter-rouge">majority</code> 레플리카 셋에서 과반수 이상의 멤버가 가진 최신의 데이터를 반환<ul><li>WiredTiger 스토리지 엔진만 지원</li><li>3.2 이상부터 지원</li><li><code class="highlighter-rouge">enableMajorityReadConcern</code> 옵션 활성화가 전제조건</li></ul></li><li><code class="highlighter-rouge">linearizable</code> 레플리카 셋의 모든 멤버가 가진 변경 사항에 대해서만 쿼리 결과를 반환<ul><li>3.4 이상부터 지원</li><li>프라이머리 멤버에서 쿼리를 실행할 때만 사용가능</li><li>레플리카 셋의 특정 멤버에 장애가 발생할 경우 무한정 대기상태에 빠질 수 있기 때문에 쿼리 타임아웃을 지정하는 것을 권장</li></ul></li></ul><h3 id="readpreference">ReadPreference</h3><p>드라이버 수준에서 클라이언트의 쿼리를 어떤 MongoDB 서버로 요청해서 실행할 것인지 결정하는 옵션이다.</p><ul><li><code class="highlighter-rouge">primary</code> 프라이머리 멤버로만 쿼리를 요청한다 (기본값, 레플리카 셋에서 프라이머리 멤버가 없으면 쿼리 실행은 실패)</li><li><code class="highlighter-rouge">primaryPreferred</code> 레플리카 셋에서 프라이머리 멤버가 없으면 세컨드리 멤버로 쿼리를 요청한다</li><li><code class="highlighter-rouge">secondary</code> 쿼리를 레플리카 셋의 세컨드리 멤버로만 요청한다 (세컨드리 멤버가 없으면 쿼리 실행은 실패)</li><li><code class="highlighter-rouge">secondaryPreferred</code> 레플리카 셋에서 세컨드리 멤버가 없으면 프라이머리 멤버로 쿼리를 요청한다</li><li><code class="highlighter-rouge">nearest</code> 레플리카 셋에서 쿼리의 응답 시간이 빠른 멤버로 쿼리를 요청한다. (레플리카 셋의 멤버들이 글로벌하게 분산되어 있을 경우에 적절한 옵션)</li></ul><blockquote><p><code class="highlighter-rouge">primaryPreferred</code> 과 <code class="highlighter-rouge">secondaryPreferred</code> 옵션을 사용하는 경우에 일시적인 장애로 커넥션에서 쿼리를 처리하는 멤버가 변경 되었을 경우에는 커넥션이 종료될 때까지 쿼리를 처리하는 멤버는 변경되지 않는다</p></blockquote><p><strong>세컨드리 읽기는 복제 지연에 대해 검토한 후에 적용하는 것이 좋다.</strong></p><ul><li>세컨드리 멤버는 OpLog 를 적용할 때 글로벌 잠금을 획득한다</li><li>세컨드리에서 실행되는 무거운 쿼리는 OpLog 적용을 지연시킨다</li><li>MongoDB 매뉴얼에서는 세컨드리 읽기를 가능하면 사용하지 않는 것을 권장한다 (정확히는 사용자 서비스를 세컨드리 읽기에서 처리하는 것)</li></ul><h2 id="데이터-모델링">데이터 모델링</h2><h3 id="컬렉션">컬렉션</h3><p>MongoDB 의 매뉴얼에서 MongoDB는 조인을 지원하지 (3.2부터 제한적으로 지원) 않기 때문에 MongoDB의 도큐먼트는 <strong>가능하면</strong> 많은 데이터를 포함할 것을 권장하고 있다.</p><p>이 권장사항은 조인 제거, 트랜잭션 보장등의 장점도 있는 반면에 단점도 존재하기 때문에 데이터 특성에 따라 적절한 트레이드 오프가 필요하다</p><p>도큐먼트의 크기가 커지면 발생하는 단점</p><ul><li>메모리 캐시 효율 저하</li><li>디스크 읽기 오퍼레이션 증가</li><li>네트워크 사용량 증가</li><li>도큐먼트의 최대 사이즈는 16MB</li></ul><h3 id="뷰">뷰</h3><ul><li>성능상의 장점은 없다</li><li>Materialized View, Updatable View 와 같은 기능은 제공하지 않는다</li><li>컬렉션을 캡슐화함으로써 얻는 장점을 제공</li><li>생성된 뷰는 컬렉션처럼 취급하면 된다 <code class="highlighter-rouge">db..find()</code>, <code class="highlighter-rouge">db..drop()</code> 등등</li></ul><h3 id="bson-도큐먼트">BSON 도큐먼트</h3><p>MongoDB는 도큐먼트를 BSON으로 처리한다 <a href="http://bsonspec.org/">BSON 스펙</a>을 한번 훑어본다면 MongoDB 사용에 도움이 될 것이다.</p><p><strong>BSON이 갖고 있는 특징</strong></p><ul><li>Lightweight 공간 최적화 : 단순히 문자열로 저장하지 않고 데이터 타입에 맞추어 이진 데이터 타입으로 저장한다</li><li>Traversable 빠른 탐색 : BSON 도큐먼트는 도큐먼트의 크기, 필드 값의 데이터 타입, 필드 값의 크기와 같은 정보를 포함하고 있어서, 빠른 탐색이 가능 하도록 설계되어 있다</li><li>Efficient 효율적 : C 언어의 Primitive 타입을 이용하기 때문에 대부분의 언어에서 빠르게 처리가 가능하다</li></ul><p><strong>도큐먼트 구성</strong><br /> 4바이트 (도큐먼트 크기)<br /> 1바이트 (필드 값의 타입)<br /> 필드 명<br /> 0x00 (필드 명의 끝)<br /> 4바이트 (필드 값의 크기)<br /> 필드 값<br /> 0x00 (필드 값의 끝)<br /> 0x00 (도큐먼트의 끝)</p><p><a href="https://github.com/JeHuiPark/blog-sample/tree/master/bson-sample">BSON 이해를 위한 샘플 코드</a></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * expected.
 *
 * {"key":"value"}
 */</span>
<span class="kd">final</span> <span class="kt">var</span> <span class="n">expected</span> <span class="o">=</span> <span class="s">"{\"key\": \"value\"}"</span><span class="o">;</span>
<span class="kt">byte</span> <span class="o">[]</span> <span class="no">INPUT_BSON</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[]{</span>
    <span class="mh">0x14</span><span class="o">,</span> <span class="mh">0x00</span><span class="o">,</span> <span class="mh">0x00</span><span class="o">,</span> <span class="mh">0x00</span><span class="o">,</span> <span class="c1">// 도큐먼트 사이즈 20</span>
    <span class="mh">0x02</span><span class="o">,</span> <span class="c1">// 문자열 필드</span>
    <span class="mh">0x6b</span><span class="o">,</span> <span class="mh">0x65</span><span class="o">,</span> <span class="mh">0x79</span><span class="o">,</span> <span class="c1">// 필드명: key</span>
    <span class="mh">0x00</span><span class="o">,</span> <span class="c1">// 필드명의 끝 (null)</span>
    <span class="mh">0x06</span><span class="o">,</span> <span class="mh">0x00</span><span class="o">,</span> <span class="mh">0x00</span><span class="o">,</span> <span class="mh">0x00</span><span class="o">,</span> <span class="c1">// 필드 길이: 6 (null 포함)</span>
    <span class="mh">0x76</span><span class="o">,</span> <span class="mh">0x61</span><span class="o">,</span> <span class="mh">0x6c</span><span class="o">,</span> <span class="mh">0x75</span><span class="o">,</span> <span class="mh">0x65</span><span class="o">,</span> <span class="c1">// 필드: value</span>
    <span class="mh">0x00</span><span class="o">,</span> <span class="c1">// 필드의 끝 (null)</span>
    <span class="mh">0x00</span> <span class="c1">// 도큐먼트의 끝 (null)</span>
<span class="o">};</span>
</code></pre></div></div><h3 id="정규화-역정규화">정규화, 역정규화</h3><p>아래는 <a href="https://wikibook.co.kr/real-mongodb/" title="대용량 데이터 처리를 위한 Real MongoDB">참고서적</a>에 적힌 내용중 하나 <img src="https://user-images.githubusercontent.com/25237661/92492094-ee149d80-f22d-11ea-95d3-e53bb88c4671.jpg" alt="KakaoTalk_20200908_234751372" /></p><h3 id="쿼리-개발-및-튜닝">쿼리 개발 및 튜닝</h3><ul><li>맵 리듀스</li><li>Aggregation</li></ul><h3 id="쿼리-실행계획">쿼리 실행계획</h3><ul><li>쿼리 실행계획 분석</li></ul><h2 id="참고서적">참고서적</h2><ul><li><a href="https://wikibook.co.kr/real-mongodb/" title="대용량 데이터 처리를 위한 Real MongoDB">대용량 데이터 처리를 위한 Real MongoDB</a></li></ul><h2 id="연결">연결</h2><ul><li><a href="/spring/embedded-mongo-issue">Springboot Embedded Mongo DB 이슈</a></li></ul><a href="#page-title" class="back-to-top">Back to Top &uarr;</a><div class="page__comments"><h4 class="page__comments-title">댓글남기기</h4><section id="disqus_thread"></section></div><script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script></div></div></div><div class="search-content"><div class="search-content__inner-wrap"><input type="text" id="search" class="search-input" tabindex="-1" placeholder="검색어를 입력해주세요..." /><div id="results" class="results"></div><h3>우측 상단의 돋보기를 누르면 원래 화면으로 돌아갈 수 있습니다.</h3></div></div><div class="page__footer"><footer> <!-- start custom footer snippets --> <!-- end custom footer snippets --><div class="page__footer-follow"><ul class="social-icons"><li><strong>팔로우:</strong></li><li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> 피드</a></li></ul></div><div class="page__footer-copyright">&copy; 2021 Dev JH. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div></footer></div><script src="/assets/js/main.min.js"></script> <script defer src="https://use.fontawesome.com/releases/v5.6.0/js/all.js" integrity="sha384-z9ZOvGHHo21RqN5De4rfJMoAxYpaVoiYhuJXPyVmSs8yn20IE3PmBM534CffwSJI" crossorigin="anonymous"></script> <script src="/assets/js/lunr/lunr.min.js"></script> <script src="/assets/js/lunr/lunr-store.js"></script> <script src="/assets/js/lunr/lunr-en.js"></script> <!-- start custom analytics snippet --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-113477172-1', 'auto'); ga('send', 'pageview'); </script> <!-- end custom analytics snippet --> <script> var disqus_config = function () { this.page.url = "https://jehuipark.github.io/study/mongo-study"; /* Replace PAGE_URL with your page's canonical URL variable */ this.page.identifier = "/study/mongo-study"; /* Replace PAGE_IDENTIFIER with your page's unique identifier variable */ }; (function() { /* DON'T EDIT BELOW THIS LINE */ var d = document, s = d.createElement('script'); s.src = 'https://https-jehuipark-github-io-blog.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <script> $(document).ready(function() { $('pre code').each(function(i, block) { try{block.className = block.parentElement.parentElement.parentElement.className.split(' ')[0].replace('language-', '')}catch(e){}; hljs.highlightBlock(block); }); hljs.initLineNumbersOnLoad(); }); </script></body></html>